#!/usr/bin/env python

import sys, os, tempfile, re

# pygtk imports
import pygtk
pygtk.require('2.0')
import gtk, gobject, pango
import gtk.gdk

from HTMLParser import HTMLParser

        


def iter_buffer(textbuffer, start=None, end=None):
    """Iterate over the items of a textbuffer"""
    
    if start == None:
        it = textbuffer.get_start_iter()
    else:
        it = start.copy()
    last = it.copy()

    if end == None:
        end = textbuffer.get_end_iter()


    # yield opening tags
    for tag in it.get_tags():
        yield ("begin", it, last, tag)
    
    while True:
        it2 = it.copy()    
        it.forward_to_tag_toggle(None)

        # yield child anchors between tags        
        while True:
            if it.get_offset() < end.get_offset():
                stop = it
            else:
                stop = end
            ret = it2.forward_search(u'\ufffc', (), stop)
            
            if ret == None:
                yield ("text", it2, stop, it2.get_text(stop))
                break
            
            a, b = ret
            anchor = a.get_child_anchor()
            
            # yield text in between tags
            yield ("text", it2, a, it2.get_text(a))
            if anchor != None:
                yield ("anchor", a, b, anchor.get_widgets())
            else:
                yield ("pixbuf", a, b, a.get_pixbuf())
            it2 = b
        
        if it.get_offset() > end.get_offset():
            break
        
        # yield closing tags
        for tag in it.get_toggled_tags(False):
            yield ("end", it, last, tag)

        # yield opening tags
        for tag in it.get_toggled_tags(True):
            yield ("begin", it, last, tag)
        
        last = it.copy()
        
        if it.equal(end):
            break


def normalize_tags(items):
    open_stack = []

    for item in items:
        kind, it, last, param = item
        if kind == "begin":
            open_stack.append(param)
            yield item

        elif kind == "end":

            # close any open out of order tags
            reopen_stack = []
            while param != open_stack[-1]:
                reopen_stack.append(open_stack.pop())
                tag2 = reopen_stack[-1]
                yield ("end", it, last, tag2)

            # close current tag
            open_stack.pop()
            yield item

            # reopen tags
            for tag2 in reversed(reopen_stack):
                open_stack.append(tag2)
                yield ("begin", it, last, tag2)

        else:
            yield item




class HtmlBuffer (HTMLParser):
    """Read and write HTML for a gtk.TextBuffer"""
    
    def __init__(self, out=None):
        HTMLParser.__init__(self)
    
        self.out = out
        self.tag2html = {}
        self.html2tag = {}
        self.size_tags = set()
        self.family_tags = set()
        self.tag_stack = []
        self.richtext = None
        self.buffer = None
        
        self.entity_char_map = [("&", "amp"),
                                (">", "gt"),
                                ("<", "lt")]
        self.entity2char = {}
        for ch, name in self.entity_char_map:
            self.entity2char[name] = ch
    
    def set_output(self, out):
        self.out = out
    
    
    def add_tag(self, tag, html_name):
        self.tag2html[tag] = html_name
        self.html2tag[html_name] = tag
    
    
    def add_size_tag(self, tag):
        self.size_tags.add(tag)
    
    
    def add_family_tag(self, tag):
        self.family_tags.add(tag)
    
    
    def read(self, richtext, infile):
        self.richtext = richtext
        self.buffer = richtext.textbuffer
        
        for line in infile:
            self.feed(line)
        
        self.buffer.place_cursor(self.buffer.get_start_iter())
    
    
    def handle_starttag(self, tag, attrs):
        if tag in ("html", "body"):
            return
    
        mark = self.buffer.create_mark(None, self.buffer.get_end_iter(), True)
        self.tag_stack.append((tag, attrs, mark))


    def handle_endtag(self, tag):
        if tag in ("html", "body"):
            return
    
        assert self.tag_stack[-1][0] == tag
        htmltag, attrs, mark = self.tag_stack.pop()
        
        if htmltag in self.html2tag:
            # get simple fonts b/i/u
            tag = self.html2tag[htmltag]
            
        elif htmltag == "br":
            # insert newline
            self.buffer.insert(self.buffer.get_end_iter(), "\n")
            return
            
        elif htmltag == "span":
            # apply style
            
            for key, value in attrs:
                if key == "style":
                    if value.startswith("font-size"):
                        size = int(value.split(":")[1].replace("pt", ""))
                        tag = self.richtext.lookup_size_tag(size)
                        
                    elif value.startswith("font-family"):
                        family = value.split(":")[1].strip()
                        tag = self.richtext.lookup_family_tag(family)
                        
                    else:
                        raise Exception("unknown style '%s'" % value)
                else:
                    raise Exception("unknown attr key '%s'" % key)
        
        else:
            raise Exception("WARNING: unhandled tag '%s'" % htmltag)
            
        start = self.buffer.get_iter_at_mark(mark)
        self.buffer.apply_tag(tag, start, self.buffer.get_end_iter())
        self.buffer.delete_mark(mark)

    def handle_data(self, data):
        data = re.sub("[\n ]+", " ", data)
        self.buffer.insert(self.buffer.get_end_iter(), data)
    
    def handle_entityref(self, name):
        self.buffer.insert(self.buffer.get_end_iter(),
                           self.entity2char.get(name, ""))
            
    
    def write(self, richtext):
        textbuffer = richtext.textbuffer
        
        self.out.write("<html><body>")
        
        for kind, it, last, param in normalize_tags(iter_buffer(textbuffer)):
            if kind == "text":
                text = param
                text = text.replace("&", "&amp;")
                text = text.replace(">", "&gt;")
                text = text.replace("<", "&lt;")
                text = text.replace("\n", "<br/>\n")
                self.out.write(text)
            
            elif kind == "begin":
                tag = param
                self.write_tag_begin(tag)
                
            elif kind == "end":
                tag = param
                self.write_tag_end(tag)
            
            elif kind == "anchor":
                for widget in param:
                    self.out.write("<img>")
            
            elif kind == "pixbuf":
                self.out.write("<pixbuf>")
        
        self.out.write("</body></html>")
        
    
    def write_tag_begin(self, tag):
        if tag in self.tag2html:
            self.out.write("<%s>" % self.tag2html[tag])
        else:
            if tag in self.size_tags:
                self.out.write("<span style='font-size: %dpt'>" % 
                          tag.get_property("size-points"))
            elif tag in self.family_tags:
                self.out.write("<span style='font-family: %s'>" % 
                          tag.get_property("family"))
            else:
                raise Exception("unknown tag")
                
        
    def write_tag_end(self, tag):
        if tag in self.tag2html:
            self.out.write("</%s>" % self.tag2html[tag])
        else:
            self.out.write("</span>")




class TakeNoteTreeView (object):
    
    def __init__(self):
        
        # create a TreeStore with one string column to use as the model
        self.treestore = gtk.TreeStore(str)

        # we'll add some data now - 4 rows with 3 child rows each
        for parent in range(4):
            piter = self.treestore.append(None, ['parent %i' % parent])
            for child in range(3):
                self.treestore.append(piter, ['child %i of parent %i' %
                                              (child, parent)])
        
        # create the TreeView using treestore
        self.treeview = gtk.TreeView(self.treestore)

        # create the TreeViewColumn to display the data
        self.tvcolumn = gtk.TreeViewColumn('Column 0')

        # add tvcolumn to treeview
        self.treeview.append_column(self.tvcolumn)

        # create a CellRendererText to render the data
        self.cell = gtk.CellRendererText()

        # add the cell to the tvcolumn and allow it to expand
        self.tvcolumn.pack_start(self.cell, True)

        # set the cell "text" attribute to column 0 - retrieve text
        # from that column in treestore
        self.tvcolumn.add_attribute(self.cell, 'text', 0)

        # make it searchable
        self.treeview.set_search_column(0)

        # Allow sorting on the column
        self.tvcolumn.set_sort_column_id(0)

        # Allow drag and drop reordering of rows
        self.treeview.set_reorderable(True)


class TakeNoteSelector (object):
    
    def __init__(self):
        
        # Create a new scrolled window, with scrollbars only if needed
        scrolled_window = gtk.ScrolledWindow()
        scrolled_window.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

        model = gtk.ListStore(gobject.TYPE_STRING)
        tree_view = gtk.TreeView(model)
        scrolled_window.add_with_viewport (tree_view)
        tree_view.show()

        # Add some messages to the window
        for i in range(10):
            msg = "Message #%d" % i
            it = model.append()
            model.set(it, 0, msg)

        cell = gtk.CellRendererText()
        column = gtk.TreeViewColumn("Messages", cell, text=0)
        tree_view.append_column(column)
        
        self.view = scrolled_window




class RichTextView (gtk.TextView):

    def __init__(self):
        gtk.TextView.__init__(self)
        self.textbuffer = self.get_buffer()
        
        # signals
        self.textbuffer.connect("mark-set", self.on_mark_set)
        self.textbuffer.connect("insert-text", self.on_insert_text)
        self.textbuffer.connect("delete-range", self.on_delete_range)
        self.textbuffer.connect("insert-pixbuf", self.on_insert_pixbuf)
        self.textbuffer.connect("insert-child-anchor", self.on_insert_child_anchor)

        self.insertid = self.textbuffer.connect("changed", self.on_changed)
        self.textbuffer.connect("begin_user_action", self.on_begin_user_action)
        self.textbuffer.connect("begin_user_action", self.on_end_user_action)
        self.textbuffer.connect("apply-tag", self.on_apply_tag)
        self.textbuffer.connect("remove-tag", self.on_remove_tag)
        
 
        self.insert_mark = None
        self.insert_type = None
        self.insert_length = None
        self.current_tags = []
        
        # font tags
        self.tag_table = self.textbuffer.get_tag_table()
        self.bold_tag = self.textbuffer.create_tag("Bold", weight=pango.WEIGHT_BOLD)
        self.italic_tag = self.textbuffer.create_tag("Italic", style=pango.STYLE_ITALIC)
        self.underline_tag = self.textbuffer.create_tag("Underline", underline=pango.UNDERLINE_SINGLE)
        
        self.html_buffer = HtmlBuffer()
        
        self.html_buffer.add_tag(self.bold_tag, "b")
        self.html_buffer.add_tag(self.italic_tag, "i")
        self.html_buffer.add_tag(self.underline_tag, "u")
        
        
        # TESTING        
        self.textbuffer.insert_at_cursor("hello")        
        #self.p = gtk.gdk.pixbuf_new_from_file("bitmaps/copy.xpm")
        #it = self.textbuffer.get_iter_at_mark(self.textbuffer.get_insert())
        #self.textbuffer.insert_pixbuf(it, self.p)
        
        image = gtk.Image()
        image.set_from_file("bitmaps/zebra.xpm")
        self.insert_image(image)
        
        self.textbuffer.insert_at_cursor("hello")
        
        image = gtk.Image()
        image.set_from_file("bitmaps/zebra.xpm")        
        self.insert_image(image)
    
    
    
    
    
    def on_mark_set(self, textbuffer, it, mark):
        if mark.get_name() == "insert":
            self.current_tags = []
            self.on_update_bold(it.has_tag(self.bold_tag))
            self.on_update_italic(it.has_tag(self.italic_tag))
            self.on_update_underline(it.has_tag(self.underline_tag))
    
    def on_insert_text(self, textbuffer, it, text, length):
        
        # remember insert location and length
        self.insert_type = "text"
        self.insert_length = length
        self.insert_mark = self.textbuffer.create_mark(None, it, True)

    def on_delete_range(self, textbuffer, start, end):
        pass    
    
    def on_insert_pixbuf(self, textbuffer, it, pixbuf):
        pass
    
    def on_insert_child_anchor(self, textbuffer, it, child):
        pass
    
    
    def on_changed(self, textbuffer):
        # apply current style to inserted text
        if self.insert_type == "text" and len(self.current_tags) > 0:
            it = self.textbuffer.get_iter_at_mark(self.insert_mark)
            it2 = it.copy()
            it2.forward_chars(self.insert_length)
            
            for tag in self.current_tags:
                self.textbuffer.apply_tag(tag, it, it2)
    
    def on_apply_tag(self, textbuffer, tag, start, end):
        pass
    
    def on_remove_tag(self, textbuffer, tag, start, end):
        pass
    
    def on_update_bold(self, enabled):
        pass

    def on_update_italic(self, enabled):
        pass

    def on_update_underline(self, enabled):
        pass


    def on_save(self):        
        #out = sys.stdout
        out = open("notes.html", "w")
        self.write_buffer(out)
        out.close()
        # testing
        #out.write("\n\n")
        #out.flush()
    
    
    def on_load(self):
        
        self.textbuffer.delete(self.textbuffer.get_start_iter(), 
                               self.textbuffer.get_end_iter())
        self.html_buffer.read(self, open("notes.html", "r"))


    def toggle_tag(self, tag):
        it = self.textbuffer.get_selection_bounds()
        
        if len(it) == 0:
            if tag not in self.current_tags:
                self.current_tags.append(tag)
            else:
                self.current_tags.remove(tag)
        else:
            if not it[0].has_tag(tag):
                self.textbuffer.apply_tag(tag, it[0], it[1])
            else:
                self.textbuffer.remove_tag(tag, it[0], it[1])

    def apply_tag(self, tag):
        it = self.textbuffer.get_selection_bounds()
        
        if len(it) == 0:
            if tag not in self.current_tags:
                self.current_tags.append(tag)
        else:
            self.textbuffer.apply_tag(tag, it[0], it[1])


    def remove_tag(self, tag):
        it = self.textbuffer.get_selection_bounds()
        
        if len(it) == 0:
            if tag in self.current_tags:
                self.current_tags.remove(tag)
        else:
            self.textbuffer.remove_tag(tag, it[0], it[1])
    
    def insert_image(self, image):
        it = self.textbuffer.get_iter_at_mark(self.textbuffer.get_insert())
        anchor = self.textbuffer.create_child_anchor(it)
        self.add_child_at_anchor(image, anchor)
    
    
    
    
    def write_buffer(self, out):
        """Write buffer to output stream"""
        
        self.html_buffer.set_output(out)
        self.html_buffer.write(self)
        
        

    def on_bold(self, widget, event):
        self.toggle_tag(self.bold_tag)
        
    def on_italic(self, widget, event):
        self.toggle_tag(self.italic_tag)
    
    def on_underline(self, widget, event):
        self.toggle_tag(self.underline_tag)
    
    def on_font_set(self, widget):
        family, mods, size = self.parse_font(widget.get_font_name())
        
        # apply family tag
        self.apply_tag(self.lookup_family_tag(family))
        
        # apply size
        self.apply_tag(self.lookup_size_tag(size))
        
        # apply mods
        for mod in mods:
            self.apply_tag(self.tag_table.lookup(mod))
        
        # disable mods not given
        for mod in ["Bold", "Italic", "Underline"]:
            if mod not in mods:
                self.remove_tag(self.tag_table.lookup(mod))
    
    
    def lookup_family_tag(self, family):
        tag = self.tag_table.lookup(family)
        if tag == None:
            tag = self.textbuffer.create_tag(family, family=family)
            self.add_family_tag(tag)
        return tag
    
    def lookup_size_tag(self, size):
        sizename = "size %d" % size
        tag = self.tag_table.lookup(sizename)
        if tag == None:
            tag = self.textbuffer.create_tag(sizename, size_points=size)
            self.add_size_tag(tag)
        return tag
    
    def add_family_tag(self, tag):
        self.html_buffer.add_family_tag(tag)
    
    def add_size_tag(self, tag):
        self.html_buffer.add_size_tag(tag)

    def parse_font(self, fontstr):
        tokens = fontstr.split(" ")
        size = int(tokens.pop())
        mods = []
        
        while tokens[-1] in ["Bold", "Italic", "Underline"]:
            mods.append(tokens.pop())

        return " ".join(tokens), mods, size
    
    
    def on_begin_user_action(self, textbuffer):
        pass

    def on_end_user_action(self, textbuffer):
        pass





class TakeNoteEditor (object):

    def __init__(self):
        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        self.textview = RichTextView()
        sw.add(self.textview)
        sw.show()
        self.textview.show()
        self.view = sw
        


class TakeNoteWindow (gtk.Window):
    def __init__(self):
        gtk.Window.__init__(self, gtk.WINDOW_TOPLEVEL)
        
        self.set_title("TakeNote")
        self.set_default_size(800, 600)
        self.connect("destroy", self.on_close)
        
        self.editor = TakeNoteEditor()
        
        # menu bar
        self.menu_items = (
            ( "/_File",         None,         None, 0, "<Branch>" ),
            ( "/File/_New",     "<control>N", None, 0, None ),
            ( "/File/_Open",    "<control>O", lambda w,e: self.editor.textview.on_load(), 0, None ),
            ( "/File/_Save",    "<control>S", lambda w,e: self.editor.textview.on_save(), 0, None ),
            ( "/File/Save _As", None,         None, 0, None ),
            ( "/File/sep1",     None,         None, 0, "<Separator>" ),
            ( "/File/Quit",     "<control>Q", gtk.main_quit, 0, None ),
            ( "/_Edit",         None,         None, 0, "<Branch>" ),            
            ( "/Edit/_Bold",    "<control>B", self.editor.textview.on_bold, 0, None ),
            ( "/Edit/_Italic", "<control>I", self.editor.textview.on_italic, 0, None ),
            ( "/Edit/_Underline", "<control>U", self.editor.textview.on_underline, 0, None ),                        
            ( "/_Options",      None,         None, 0, "<Branch>" ),
            ( "/Options/Test",  None,         None, 0, None ),
            ( "/_Help",         None,         None, 0, "<LastBranch>" ),
            ( "/_Help/About",   None,         None, 0, None ),
            )

        main_vbox = gtk.VBox(False, 1)
        self.add(main_vbox)
        
        main_vbox.set_border_width(1)
        menubar = self.make_menubar(self.menu_items)
        main_vbox.pack_start(menubar, False, True, 0)
        
        
        # toolbar
        handlebox = gtk.HandleBox()
        toolbar = gtk.Toolbar()
        toolbar.set_orientation(gtk.ORIENTATION_HORIZONTAL)
        toolbar.set_style(gtk.TOOLBAR_ICONS)
        toolbar.set_border_width(0)
        handlebox.add(toolbar)
        main_vbox.pack_start(handlebox, False, True, 0)
        
        # our first item is <close> button
        iconw = gtk.Image() # icon widget
        iconw.set_from_file("bitmaps/open.xpm")
        close_button = toolbar.append_item(
            "Close",           # button label
            "Exit TakeNote", # this button's tooltip
            "Private",         # tooltip private info
            iconw,             # icon widget
            self.on_close)     # a signal
        #toolbar.append_space() # space after item
        
        self.font_sel = gtk.FontButton()
        toolbar.append_widget(self.font_sel, "Choose font", "")
        self.font_sel.connect("font-set", self.editor.textview.on_font_set)
        
        
        # create a hpaned widget and add it to our toplevel window
        hpaned = gtk.HPaned()
        main_vbox.pack_start(hpaned, True, True, 0)
        hpaned.set_position(150)

        # create a vpaned widget and add it to our toplevel window
        vpaned = gtk.VPaned()
        hpaned.add2(vpaned)
        vpaned.set_position(200)
        
        
        # status bar
        self.status_bar = gtk.Statusbar()      
        main_vbox.pack_start(self.status_bar, False, True, 0)  


        # add treeview
        self.treeview = TakeNoteTreeView()
        hpaned.add1(self.treeview.treeview)
        
        
        # add note selector
        self.selector = TakeNoteSelector()
        vpaned.add1(self.selector.view)
        #self.selector.view.show()
        
        
        # add note editor        
        vpaned.add2(self.editor.view)


        self.show_all()
        self.editor.textview.grab_focus()        
    
    
    def on_bold(self, widget, event):
        self.editor.on_bold(widget, event)
    
    
    # close the window and quit
    def on_close(self, widget):
        gtk.main_quit()
        return False
    
    
    def make_menubar(self, menu_items):
        accel_group = gtk.AccelGroup()

        # This function initializes the item factory.
        # Param 1: The type of menu - can be MenuBar, Menu,
        #          or OptionMenu.
        # Param 2: The path of the menu.
        # Param 3: A reference to an AccelGroup. The item factory sets up
        #          the accelerator table while generating menus.
        item_factory = gtk.ItemFactory(gtk.MenuBar, "<main>", accel_group)

        # This method generates the menu items. Pass to the item factory
        #  the list of menu items
        item_factory.create_items(menu_items)

        # Attach the new accelerator group to the window.
        self.add_accel_group(accel_group)

        # need to keep a reference to item_factory to prevent its destruction
        self.item_factory = item_factory
        # Finally, return the actual menu bar created by the item factory.
        return item_factory.get_widget("<main>")



class TakeNote (object):
    
    def __init__(self):        
        self.window = TakeNoteWindow()
        
        




#=============================================================================

def main():
    gtk.main()

if __name__ == "__main__":
    app = TakeNote()
    main()
